# ==== Purpose ====
#
# This test verifies that deadlock errors arising due to lock conflicts are
# handled properly when --slave-preserve-commit-order is enabled on the replica
# server.
#
# ==== Implementation ====
#
# 1. Create source-replica topolgy.
# 2. Setup testing environment.
#    2.1. Create table on source and insert few rows.
#    2.2. Setup necessary variables on replica server.
# 3. Execute transactions on source server that would generate deadlock on the
#    replica server.
#
#    The commands used to generate deadlock in this test are:
#
#    INSERT INTO t1 (11, NULL);
#    DELETE FROM t1 WHERE c2 <= 3;
#
#    With the help of debug points on the source server, simulate that they are
#    executed parallely on master and make sure INSERT is binlogged before
#    DELETE.
#
#    On replica server, they are applied parallel by w1 and w2. And the deadlock is:
#      w1                                        w2
#    -------------------------                 --------------------------
#     applying INSERT                          applying DELETE
#                                              get the row locks first.
#     waiting for w1 to release
#     the row lock.
#                                              waiting for w2 to commit
#
#     For these two special statements, INSERT doesn't block DELETE, but DELETE
#     does block the INSERT because of the gap locks.
#
# 4. Wait till server to handle the deadlock and till the co-ordinator
#    thread to error out with ER_MTS_INCONSISTENT_DATA.
# 5. Restart the replication threads, sync the replica and verify that table data is
#    consistent.
# 6. Cleanup.
#
# ==== References ====
#
# PS-7232 Multithreaded Slave hangs when slave_transaction_retries=0
# PS-7197 Multi-threaded slave randomly stacks

# The test needs debug binaries
--source include/have_debug.inc
--source include/have_debug_sync.inc
--source include/have_binlog_format_statement.inc

--echo #
--echo # 1. Create source-replica topolgy.
--source include/master-slave.inc

--echo #
--echo # 2. Setup testing environment.
--echo #    2.1. Create table on source and insert few rows.
--echo #    2.2. Setup necessary variables on replica server.

CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, INDEX(c2)) ENGINE = InnoDB;
INSERT INTO t1 VALUES(1, NULL),(2, 2), (3, NULL), (4, 4), (5, NULL), (6, 6);

--source include/sync_slave_sql_with_master.inc
--source include/stop_slave_sql.inc
SET @saved_slave_parallel_type = @@GLOBAL.slave_parallel_type;
SET @saved_slave_parallel_workers = @@GLOBAL.slave_parallel_workers;
SET @saved_slave_preserve_commit_order = @@GLOBAL.slave_preserve_commit_order;
SET @saved_innodb_lock_wait_timeout = @@GLOBAL.innodb_lock_wait_timeout;
SET @saved_slave_transaction_retries = @@GLOBAL.slave_transaction_retries;

SET GLOBAL slave_transaction_retries = 0;
SET GLOBAL slave_parallel_type = "LOGICAL_CLOCK";
SET GLOBAL slave_parallel_workers = 3;
SET GLOBAL slave_preserve_commit_order = ON;
# Set it a long time to guarantee it doens't report an timeout error
SET GLOBAL innodb_lock_wait_timeout = 1000;

--echo #
--echo # 3. Execute transactions on source server that would generate deadlock on the
--echo #    replica server.
--source include/rpl_connection_master.inc

# There is a bug that the first two transactions cannot be applied parallel.
# So we need to an extra transaction here.
INSERT INTO t1 VALUES(10, 10);

--let $debug_point= set_commit_parent_100
--source include/add_debug_point.inc
INSERT INTO t1 VALUES(11, NULL);
DELETE FROM t1 WHERE c2 <= 3;
INSERT INTO t1 VALUES(15, 15);
--source include/remove_debug_point.inc

# Start a local transaction on replica server to block the INSERT statement coming
# through the replication channel.
--source include/rpl_connection_slave.inc
BEGIN;
INSERT INTO t1 VALUES(11, 11);

# Enable the debug point to delay w3 entering the commit.
--source include/rpl_connection_slave1.inc
--let $debug_point = delay_slave_worker_3
--source include/add_debug_point.inc
--source include/start_slave_sql.inc

# Wait till w3 enters the sync point during commit.
SET DEBUG_SYNC = 'now WAIT_FOR signal.w3.wait_for_its_turn';

# Wait till DELETE statement(w2) waits for the the preceding transaction(w1) to commit.
--let $wait_condition= SELECT count(*) = 1 FROM information_schema.processlist WHERE STATE = "Waiting for preceding transaction to commit"
--source include/wait_condition.inc

# Resume the INSERT statement from replication channel and trigger the deadlock
--source include/rpl_connection_slave.inc
ROLLBACK;

# When the INSERT statement proceeds, the w1 finds deadlock with w2, and it
# will ask w2 to rollback. When w2 rolls back the transaction, it would check
# the value of slave_trans_retries before retrying the transaction. Since, we
# have set it to 0 throughout the test, the w2 shall not retry the transaction
# and would call report_rollback.
#
# Without the fix for PS-7232, calling report_rollback() would make the w2 to
# return without removing its entry from the SPCO queue thus resulting in w3 to
# wait forever on the signal. Meanwhile if co-ordinator was asked to go down by
# any of the previous workers, this would make co-ordinator thread to wait for
# the workers to finish thus leading to server hang.

--let $wait_timeout = 60
--let $wait_condition = SELECT count(*) = 1 FROM information_schema.processlist WHERE STATE = "Waiting for workers to exit"
--source include/wait_condition.inc

SET DEBUG_SYNC = 'now SIGNAL go_ahead_w3';
SET DEBUG_SYNC = 'RESET';

--echo # 4. Wait till server to handle the deadlock and till the co-ordinator
--echo #    thread to error out with ER_MTS_INCONSISTENT_DATA.
--let $slave_sql_errno = convert_error(ER_MTS_INCONSISTENT_DATA)
--source include/wait_for_slave_sql_error.inc

# Remove the debug point
--let $debug_point = delay_slave_worker_3
--source include/remove_debug_point.inc

--echo #
--echo # 5. Restart replication threads, sync the replica and verify that table
--echo #    data is consistent.
--source include/start_slave_sql.inc
--source include/rpl_connection_master.inc
--source include/sync_slave_sql_with_master.inc

--let $rpl_diff_statement= SELECT * FROM t1;
--source include/rpl_diff.inc

--echo #
--echo # 6. Cleanup.

--source include/rpl_connection_slave.inc
--source include/stop_slave_sql.inc
SET GLOBAL slave_transaction_retries = @saved_slave_transaction_retries;
SET GLOBAL slave_parallel_type = @saved_slave_parallel_type;
SET GLOBAL slave_parallel_workers = @saved_slave_parallel_workers;
SET GLOBAL slave_preserve_commit_order = @saved_slave_preserve_commit_order;
SET GLOBAL innodb_lock_wait_timeout = @saved_innodb_lock_wait_timeout;
--source include/start_slave_sql.inc

# Add suppressions on replica server.
CALL mtr.add_suppression("Consider raising the value of the slave_transaction_retries variable");
CALL mtr.add_suppression("Deadlock found when trying to get lock; try restarting transaction");
CALL mtr.add_suppression("The slave coordinator and worker threads are stopped, possibly leaving data in inconsistent state.");

--source include/rpl_connection_master.inc
DROP TABLE t1;
--source include/rpl_end.inc
